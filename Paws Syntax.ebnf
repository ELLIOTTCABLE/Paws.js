(* First off, this document conforms to the Bytewise EBNF language described
 * here: <http://odin.himinbi.org/bytewise_ebnf/ebnf_spec.html> (although some
 * of the more esoteric features, such as ‘named groups’ [which break the
 * context-free rule of EBNF grammars] and byte specifications in string
 * literals). That syntax is based on ISO-14977, Extended BNF:
 * <http://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf>.
 * 
 * Second, due to the compile-time interpretation rules, it is impossible to
 * describe the operator set in this document. Instead, these special
 * extensions each match any entry in the corresponding deterministic compile-
 * time table:
 * - `? left-associative unary operator ?`
 * - `? right-associative unary operator ?`
 * - `? left-associative binary operator ?`
 * - `? right-associative binary operator ?`
 * 
 * In addition, we can’t regularly describe the semantics of meaningful
 * indentation, thus we use the following extension to represent the series of
 * ‘whitespace’ (see the definition under ‘Supporting elements’ near the end
 * of this document) characters *exactly equal* to the those preceding the
 * current line (that is, the line being processed when the token is needed):
 * - `? indentation ?`
 * 
 * Finally, precedence flows from top to bottom (that is, the more precedent
 * rules are later). I’m fairly sure that’s not standard Backus-Naur, but I’m
 * writing this document for humans, not for existing EBNF parsers. This
 * allows to place the more conceptually-atomic units of syntax earlier, and
 * override them with more complex rules later (for instance, I can place
 * `word` first, without specifying that a `word` cannot end in a semicolon—
 * because wherever a semi)
 *)

(* The basic conceptual unit of the Paws grammar is the ‘word.’ It consists
 * of any number of consecutive visible, printable characters (thus excluding
 * control characters, whitespace, and so on, but including all other
 * character sets and punctuation.)
 *)
word       = grapheme{1,∞};
identifier = word | sentence;

(* It’s important to note how simple the ‘sentence’ syntax is; only the
 * simplest of escapes is supported. If you want to do anything more complex
 * with weird nested quotes and backslashes, you should be using separate
 * strings and concatenation. Also note that the forward slashes are double-
 * escaped literally in *this document*, according to the rules.
 * 
 * Also note that the handling of escapes is intentionally simple: This syntax
 * *treats* `“\u”` as an ‘escaped character’ in a string, but the interpreter
 * does not. That is the exact equivalent of `“\\u”`; the only place wherein
 * a forward slash is *actually meaningful*, in the *interpreter*, is prior to
 * another forward slash, or prior to the appropriate closing quote for the
 * respective sentence type.
 *)
escaped character      = "\\", [^];
double-quoted sentence = '"', (escaped character | [^\\"]){0,∞}, '"';
single-quoted sentence = "'", (escaped character | [^\\']){0,∞}, "'";

(* Unicode curly-quotes are *fully supported* by Paws, in that they are
 * intelligently paired by the parser. A closing curly-quote in a quoted
 * ‘sentence,’ as long as it’s properly paired, doesn’t necessarily end said
 * ‘sentence.’
 * 
 * For instance, the following is a perfectly valid, single ‘sentence:’
 * 
 *     “He said: “We’re going!””
 *)
curly double-quoted sentence = "“", (curly double-quoted sentence |
  escaped character | [^\\”]){0,∞}, "”";
curly single-quoted sentence = '‘', (curly single-quoted sentence |
  escaped character | [^\\’]){0,∞}, '’';

sentence =
        single-quoted sentence |       double-quoted sentence |
  curly single-quoted sentence | curly double-quoted sentence;

(* Routines are a series of statements.
 *--
 * FIXME: This doesn’t handle multiple indentation-series ending
 *        simultaneously, for instance:
 *        
 *            scope
 *               scope
 *                foo
 *            bar
 *        
 *        In that example, the `\n    foo\n` after the second `scope`
 *        ‘identifier’ would not be appropriately recognized as an ‘implicit
 *        routine literal’, because at least `\n   ` would be expected.
 * FIXME: An implicit routine literal doesn’t properly end a statement; that
 *        is, a newline normally ends a statement, but the following code
 *        would be parsed instead as a *single* statement:
 *        
 *            if([ a = b ])
 *              foo
 *            bar
 *        
 *        That means that `bar` would be looked up on the result of the `if()`
 *        call, as if the statement looked like this:
 *        
 *            if([ a = b ]) {
 *              foo
 *            } bar;
 *)
explicit routine literal = "{", optional statements, "}";
implicit routine literal = "\n",
  ? indentation ?, whitespace, optional statements, "\n",
  ? indentation ?;

routine literal = explicit routine literal | implicit routine literal;

(* Most common Paws operations are ‘space operations.’ This involves the
 * lookup of the ‘word’ on the right of the space, on the result of
 * the ‘expression’ on the left. Instead of a normal ‘identifier’ on the
 * right, a ‘parenthetical expression’ may be used, in which case an
 * “indirected lookup” is preformed. Generally, this means the result of the
 * ‘parenthetical expression’ are looked up, instead of the ‘identifier’
 * itself.
 * 
 * In the case of routines, a ‘space operation’ may trigger an execution. A
 * ‘routine literal’ may follow a ‘space operation,’ in which case it will be
 * applied to such a call or lookup.
 *)
space operation = expression,
  (whitespace, identifier | optional whitespace, parenthetical expression),
  (optional whitespace, routine literal){0,∞};

(* Operators in Paws are fully dynamic, however, there are a small number that
 * are specially handled. Those are directly defined in the syntax; they
 * override default naming rules (for instance, `foo,` is ‘word,
 * separating operator’ instead of a single ‘word’ with the `string`-content
 * “foo,”). These include:
 * 
 * - “~”, not directly preceded by an identifier
 * - “,”, not directly followed by an identifier
 * - “|”, not directly followed by an identifier
 * - “:”, not directly followed by an identifier
 * 
 * Most Paws operators are Unicode outside of the ASCII range; however,
 * because Paws aims to fully *support* plain-ASCII programming, if perhaps to
 * avoid encouraging it, all of these interpreter-supported, *hardcoded*
 * operators, are from the plain ASCII subset. This implies that a purely-
 * ASCII standard library *could* eventually be developed.
 *)
separating operator  = "," | "|" | ":";
separating operation =
  expression, optional whitespace, separating operator, whitespace, expression;

enlisting operator  = "~";
enlisting operation = enlisting operator, optional whitespace, expression;

operation = (space operation | separating operation | enlisting operation);

(* An ‘expression’ in Paws, is something which can, possibly, be materialized.
 * That is, it has the *possibility* of having some sort of inherent meaning
 * or intrinsic semantic value; of directly mapping to a “result value” of
 * some sort.
 *)
parenthetical expression = "(", optional statements, ")";
expression = (identifier | explicit routine literal | operation |
  parenthetical expression);

(* A ‘statement’ is a complete, standalone ‘expression.’ The overall
 * ‘expression’ will never be materialized at the completion of the
 * ‘statement’; only sub-elements necessarily material to the execution of the
 * ‘expression’ will be.
 *)
statement = expression, optional whitespace, (";", optional whitespace | "\n");

(* The ‘source unit’ is the overall unit of syntax. A ‘source unit’ contains
 * any number of sequential ‘statements.’ In this way, it is identical to a
 * ‘routine.’
 *)
source unit = optional statements;

(* *******************}
| Supporting elements |
{******************* *)

grapheme            = [[:graph:]];

whitespace          = [[:space:]]{1,∞};
optional whitespace = [[:space:]]{0,∞};

(* Anywhere a series of statements is valid, a series of statements followed
 * by an unterminated statement (which is, essentially, just an expression) is
 * also valid.
 *)
optional statements = statement{0,∞}, expression{0,1};
