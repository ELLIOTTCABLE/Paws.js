#!/usr/bin/env node ../../Executables/paws.js --no-start
implementation void()

   Let's combine some of this, and put it towards the task of creating a new `execution` that we can
   call by its name.


   First, we'll provide a shortcut-character to reference `infrastructure`, to abbreviate our code,
 ( infrastructure execution stage()
      (infrastructure affix() (locals))
      (infrastructure empty())                                                )
 ( infrastructure execution stage()
      (infrastructure own() (locals))
      (infrastructure length() (locals))                                      )

 ( infrastructure execution stage()
     (infrastructure affix() 
       ( infrastructure get() (locals) (infrastructure length() (locals)) ))
      ‡                                                                       )
 ( infrastructure execution stage()
     (infrastructure affix() 
       ( infrastructure get() (locals) (infrastructure length() (locals)) ))
      (infrastructure)                                                        )


   Next, we store our actual routine in the `locals`.
 ( ‡ execution stage()  (‡ affix() (locals))(‡ empty())                       )
 ( ‡ execution stage()  (‡ own() (locals))(‡ length() (locals))            )

 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )my.routine          )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )
      { implementation console print Phew,that.worked. }                      )


   Next, we want to access the `<execution> locals`, but we can't get that by combining, because
   the combination-receiver for `execution`s would *stage* it. Instead, we're going to extract the
   `thing` receiver, and manually invoke it with a receiver-parameters object.
   
   So here, we construct a parameters object to get a reference to `locals` out of the receiver:
 ( ‡ execution stage()  (‡ affix() (locals))(‡ empty())                       )
 ( ‡ execution stage()  (‡ own() (locals))(‡ length() (locals))            )

 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )parameters          )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )(‡ empty())         )

 ( ‡ execution stage()  (‡ set() (parameters) 1)()                            )
 ( ‡ execution stage()  (‡ set() (parameters) 2)(my.routine)                  )
 ( ‡ execution stage()  (‡ set() (parameters) 3)locals                        )

 
   Now we get an arbitrary `thing`'s receiver, and invoke it with our parameters.
 ( ‡ execution stage()  (‡ affix() (locals))(‡ empty())                       )
 ( ‡ execution stage()  (‡ own() (locals))(‡ length() (locals))            )

 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )my.locals           )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (locals) (‡ length() (locals))) )
       ( ‡ receiver() (‡ empty()) (parameters) )                              )

   Finally, the reason for all that madness: we need to get `implementation` and `infrastructure`
   into our routine's `locals`, since they're only injected into our environment at this root level.
 ( ‡ execution stage()  (‡ affix() (my.locals))(‡ empty())                    )
 ( ‡ execution stage()  (‡ own() (my.locals))(‡ length() (my.locals))      )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (my.locals) (‡ length() (my.locals))) )
         infrastructure                                                       )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (my.locals) (‡ length() (my.locals))) )
         (infrastructure)                                                     )
 
 ( ‡ execution stage()  (‡ affix() (my.locals))(‡ empty())                    )
 ( ‡ execution stage()  (‡ own() (my.locals))(‡ length() (my.locals))      )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (my.locals) (‡ length() (my.locals))) )
         implementation                                                       )
 ( ‡ execution stage()
    ( ‡ affix() (‡ get() (my.locals) (‡ length() (my.locals))) )
         (implementation)                                                     )


   And now, the reveal:

 ( ‡ execution stage() (my.routine)()                                         )

   Yay! <3
